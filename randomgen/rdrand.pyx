try:
    from threading import Lock
except ImportError:
    from dummy_threading import Lock

from libc.string cimport memcpy
from cpython.pycapsule cimport PyCapsule_New

import numpy as np
cimport numpy as np

from randomgen.common cimport *
from randomgen.distributions cimport bitgen_t
from randomgen.entropy import random_entropy, seed_by_array

__all__ = ['RDRAND']

np.import_array()

cdef extern from "src/rdrand/rdrand.h":

    struct s_rdrand_state:
        int status

    ctypedef s_rdrand_state rdrand_state

    uint64_t rdrand_next64(rdrand_state* state)  nogil
    uint32_t rdrand_next32(rdrand_state* state)  nogil
    int rdrand_capable()

cdef uint64_t rdrand_uint64(void* st) nogil:
    return rdrand_next64(<rdrand_state*>st)

cdef uint32_t rdrand_uint32(void *st) nogil:
    return rdrand_next32(<rdrand_state*>st)

cdef double rdrand_double(void* st) nogil:
    return uint64_to_double(rdrand_next64(<rdrand_state*>st))

cdef class RDRAND:
    """
    RDRAND(seed=None)

    Container for the hardware RDRAND random number generator.

    Parameters
    ----------
    seed : None
        Must be None. Raises if any other value is passed.

    Attributes
    ----------
    lock: threading.Lock
        Lock instance that is shared so that the same bit git generator can
        be used in multiple Generators without corrupting the state. Code that
        generates values from a bit generator should hold the bit generator's
        lock.

    Notes
    -----
    RDRAND is a hardware random number generator that is available on Intel
    processors from the Ivy Bridge line (2012) or later, and AMD processors
    starting in 2015.

    RDRAND has been audited and is reported to be a secure generator. It is
    **much slower** than software BitGenerators and so is only useful in
    applications where security is more important than performance.

    **State and Seeding**

    Results from ``RDRAND`` are **NOT** reproducible.

    ``RDRAND`` uses a hardware generated seed and so cannot be seeded. The
    state contains a single integer value ``status`` that takes the value 1
    if all calls have succeeded and 0 if any fail. A failure of a call to
    RDRAND does not propogate, and so users much check this value to determine
    if results are random.

    **Parallel Features**

    ``RDRAND`` is stateless and so multiple instances can be used in parallel.

    >>> from randomgen import Generator, RDRAND
    >>> rg = [Generator(RDRAND()) for _ in range(10)]

    **No Compatibility Guarantee**

    ``RDRAND`` is hardware dependent and not reproducible, and so there is no
    stream guarantee.

    Raises
    ------
    RuntimeError
        If RDRAND is not available on the platform.

    Examples
    --------
    >>> from randomgen import Generator, RDRAND
    >>> rg = Generator(RDRAND())
    >>> rg.standard_normal()
    0.123  # random
    """
    cdef rdrand_state rng_state
    cdef bitgen_t _bitgen
    cdef public object capsule
    cdef object _ctypes
    cdef object _cffi
    cdef public object lock

    def __init__(self, seed=None):
        available = rdrand_capable()
        if not available:
            raise RuntimeError('RDRAND is not available')
        self.rng_state.status = 1
        self.seed(seed)
        self.lock = Lock()

        self._bitgen.state = <void *>&self.rng_state
        self._bitgen.next_uint64 = &rdrand_uint64
        self._bitgen.next_uint32 = &rdrand_uint32
        self._bitgen.next_double = &rdrand_double
        self._bitgen.next_raw = &rdrand_uint64

        self._ctypes = None
        self._cffi = None

        cdef const char *name = "BitGenerator"
        self.capsule = PyCapsule_New(<void *>&self._bitgen, name, NULL)

    # Pickling support:
    def __getstate__(self):
        return self.state

    def __setstate__(self, state):
        self.state = state

    def __reduce__(self):
        from randomgen._pickle import __bit_generator_ctor
        return __bit_generator_ctor, (self.state['bit_generator'],), self.state

    def random_raw(self, size=None, output=True):
        """
        random_raw(self, size=None)

        Return randoms as generated by the underlying BitGenerator

        Parameters
        ----------
        size : int or tuple of ints, optional
            Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
            ``m * n * k`` samples are drawn.  Default is None, in which case a
            single value is returned.
        output : bool, optional
            Output values.  Used for performance testing since the generated
            values are not returned.

        Returns
        -------
        out : uint or ndarray
            Drawn samples.

        Notes
        -----
        This method directly exposes the the raw underlying pseudo-random
        number generator. All values are returned as unsigned 64-bit
        values irrespective of the number of bits produced by the PRNG.

        See the class docstring for the number of bits returned.
        """
        return random_raw(&self._bitgen, self.lock, size, output)

    def _benchmark(self, Py_ssize_t cnt, method=u'uint64'):
        return benchmark(&self._bitgen, self.lock, cnt, method)

    def seed(self, seed=None):
        """
        seed(seed=None)

        Parameters
        ----------
        seed : None
            Must be None. Raises if any other value is passed.

        Raises
        ------
        ValueError
            If seed is not None
        """
        if seed is not None:
            raise TypeError('seed cannot be set and so must be None')

    def jumped(self, iter=1):
        """
        jumped(iter=1)

        Returns a new bit generator

        ``RDRAND`` is stateless and so the new generator can be used in a
        parallel applications.

        Parameters
        ----------
        iter : integer, positive
            This parameter is ignored

        Returns
        -------
        bit_generator : RDRAND
            New instance of generator jumped iter times

        Notes
        -----
        Provided for API compatibility
        """
        cdef RDRAND bit_generator
        bit_generator = self.__class__()

        return bit_generator

    @property
    def state(self):
        """
        Get or set the PRNG state

        Returns
        -------
        state : dict
            Dictionary containing the information required to describe the
            state of the PRNG
        """
        return {'bit_generator': self.__class__.__name__,
                'status': self.rng_state.status}

    @state.setter
    def state(self, value):
        if not isinstance(value, dict):
            raise TypeError('state must be a dict')
        bitgen = value.get('bit_generator', '')
        if bitgen != self.__class__.__name__:
            raise ValueError('state must be for a {0} '
                             'PRNG'.format(self.__class__.__name__))

    @property
    def ctypes(self):
        """
        ctypes interface

        Returns
        -------
        interface : namedtuple
            Named tuple containing ctypes wrapper

            * state_address - Memory address of the state struct
            * state - pointer to the state struct
            * next_uint64 - function pointer to produce 64 bit integers
            * next_uint32 - function pointer to produce 32 bit integers
            * next_double - function pointer to produce doubles
            * bitgen - pointer to the bit generator struct
        """
        if self._ctypes is None:
            self._ctypes = prepare_ctypes(&self._bitgen)

        return self._ctypes

    @property
    def cffi(self):
        """
        CFFI interface

        Returns
        -------
        interface : namedtuple
            Named tuple containing CFFI wrapper

            * state_address - Memory address of the state struct
            * state - pointer to the state struct
            * next_uint64 - function pointer to produce 64 bit integers
            * next_uint32 - function pointer to produce 32 bit integers
            * next_double - function pointer to produce doubles
            * bitgen - pointer to the bit generator struct
        """
        if self._cffi is not None:
            return self._cffi
        self._cffi = prepare_cffi(&self._bitgen)
        return self._cffi
